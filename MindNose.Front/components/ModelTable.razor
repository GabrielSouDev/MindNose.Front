@using System.Globalization
@using MindNose.Front.Models.Response.LLMModels
@using Radzen
@inject OpenRouterService OpenRouterService

<RadzenStack Gap="2rem" Orientation="Orientation.Vertical" Style="margin: 15px;">

    <!-- Filtros -->
    <RadzenCard Style="padding: 1rem;">
        <RadzenStack Orientation="Orientation.Horizontal" Gap="1rem" Wrap="FlexWrap.Wrap">
            <RadzenTextBox @bind-Value="filterName" Placeholder="Filtrar por palavra-chave" Style="width: 200px;" Change="@((_) => ApplyFilter())" />
            <RadzenDropDown @bind-Value="selectedModality" Data="@modalities" Placeholder="Modalidade" AllowClear="true" Style="width: 200px;" Change="@((_) => ApplyFilter())" />
            <RadzenDropDown @bind-Value="selectedContextRange" Data="@contextRanges" Placeholder="Contexto mínimo" AllowClear="true" Style="width: 200px;" Change="@((_) => ApplyFilter())" />
            <RadzenDropDown @bind-Value="selectedPriceRange" Data="@priceRanges" Placeholder="Faixa de preço" Style="width: 200px;" Change="@((_) => ApplyFilter())" />
            <RadzenDropDown @bind-Value="selectedModeration" Data="@moderationOptions" Placeholder="Moderação" Style="width: 150px;" Change="@((_) => ApplyFilter())" />
            <RadzenDropDown @bind-Value="selectedColumns" Data="@ColumnMeta.Keys.ToList()" Placeholder="Selecionar colunas" Style="width: 300px;" Multiple="true" Change="@((_) => UpdateVisibleColumns())" />
            <RadzenButton Text="Aplicar Filtro" Click="@ApplyFilter" Style="margin-left: auto;" />
        </RadzenStack>
    </RadzenCard>

    <RadzenCard>
        <!-- Tabela -->
        @if (filteredModels != null)
        {
            <RadzenDataGrid Data="@filteredModels" TItem="Model"
                            ColumnWidth="200px"
                            AllowPaging="true"
                            PageSize="@pageSize"
                            PageSizeChanged="@((int size) => pageSize = size)"
                            PageSizeOptions="@pageSizeOptions"
                            PagerPosition="PagerPosition.Bottom"
                            AllowSorting="true"
                            Style="height: auto; min-height: 500px;">
                <Columns>
                    @foreach (var column in visibleColumns.Where(c => c.Value))
                    {
                        var meta = ColumnMeta[column.Key];
                        var sortable = !new[] { "InputModalities", "OutputModalities", "InstructType" }.Contains(column.Key);

                        <RadzenDataGridColumn Title="@meta.PrettyName"
                                              Property="@meta.PropertyPath"
                                              Sortable="@sortable">
                            <Template Context="Model">
                                <span title="@meta.ValueSelector(Model)">
                                    @meta.ValueSelector(Model)
                                </span>
                            </Template>
                        </RadzenDataGridColumn>
                    }
                </Columns>
            </RadzenDataGrid>
        }
    </RadzenCard>
</RadzenStack>

@code {
    private ModelResponse _models { get; set; } = new();
    private List<Model> filteredModels = new();
    private List<string> modalities = new();
    private List<string> selectedColumns = new();

    private string filterName = string.Empty;
    private string? selectedModality;
    private string? selectedPriceRange;
    private string? selectedModeration;
    private string? selectedContextRange;

    private int pageSize = 50;
    private readonly List<int> pageSizeOptions = new() { 10, 20, 50, 100, 200, 500 };

    // --- META CENTRALIZADA ---
    private readonly Dictionary<string, (string PrettyName, string PropertyPath, Func<Model, string> ValueSelector)> ColumnMeta =
        new()
        {
            ["Id"] = ("ID", "Id", m => m.Id ?? ""),
            ["Name"] = ("Nome", "Name", m => m.Name ?? ""),
            ["Created"] = ("Criado em", "Created",
                m => m.Created.HasValue ? DateTimeOffset.FromUnixTimeSeconds(m.Created.Value).ToLocalTime().ToString("g") : ""),
            ["Description"] = ("Descrição", "Description", m => m.Description ?? ""),
            ["ContextLength"] = ("Comprimento do Contexto", "ContextLength", m => m.ContextLength?.ToString("N0") ?? "—"),
            ["Modality"] = ("Modalidade", "Architecture.Modality", m => m.Architecture?.Modality ?? "—"),
            ["InputModalities"] = ("Modalidades de Entrada", "Architecture.InputModalities", m => string.Join(", ", m.Architecture?.InputModalities ?? new())),
            ["OutputModalities"] = ("Modalidades de Saída", "Architecture.OutputModalities", m => string.Join(", ", m.Architecture?.OutputModalities ?? new())),
            ["Tokenizer"] = ("Tokenizer", "Architecture.Tokenizer", m => m.Architecture?.Tokenizer ?? "—"),
            ["InstructType"] = ("Tipo de Instrução", "Architecture.InstructType", m => m.Architecture?.InstructType?.ToString() ?? "—"),
            ["Prompt"] = ("Preço (Prompt)", "Pricing.Prompt", m => FormatPrice(m.Pricing?.Prompt)),
            ["Completion"] = ("Preço (Completion)", "Pricing.Completion", m => FormatPrice(m.Pricing?.Completion)),
            ["InputCacheRead"] = ("Leitura do Cache de Entrada", "Pricing.InputCacheRead", m => FormatPrice(m.Pricing?.InputCacheRead)),
            ["InputCacheWrite"] = ("Gravação no Cache de Entrada", "Pricing.InputCacheWrite", m => FormatPrice(m.Pricing?.InputCacheWrite)),
            ["Audio"] = ("Preço (Áudio)", "Pricing.Audio", m => FormatPrice(m.Pricing?.Audio, false)),
            ["Request"] = ("Preço (Requisição)", "Pricing.Request", m => FormatPrice(m.Pricing?.Request)),
            ["Image"] = ("Preço (Imagem)", "Pricing.Image", m => FormatPrice(m.Pricing?.Image, true)),
            ["WebSearch"] = ("Preço (Busca Web)", "Pricing.WebSearch", m => FormatPrice(m.Pricing?.WebSearch, false)),
            ["InternalReasoning"] = ("Preço (Raciocínio Interno)", "Pricing.InternalReasoning", m => FormatPrice(m.Pricing?.InternalReasoning)),
            ["IsModerated"] = ("Moderado?", "TopProvider.IsModerated", m => m.TopProvider?.IsModerated == true ? "✅" : "❌"),
            ["TopProviderContextLength"] = ("Contexto (Top Provider)", "TopProvider.ContextLength", m => m.TopProvider?.ContextLength?.ToString("N0") ?? "—"),
            ["MaxCompletionTokens"] = ("Máx. Tokens de Conclusão", "TopProvider.MaxCompletionTokens", m => m.TopProvider?.MaxCompletionTokens?.ToString() ?? "—"),
            ["PerRequestLimits"] = ("Limites por Requisição", "PerRequestLimits", m => m.PerRequestLimits?.ToString() ?? "—"),
        };

    private Dictionary<string, bool> visibleColumns = new()
    {
        ["Id"] = false,
        ["Name"] = true,
        ["ContextLength"] = true,
        ["Description"] = false,
        ["Modality"] = true,
        ["InputModalities"] = false,
        ["OutputModalities"] = false,
        ["Tokenizer"] = true,
        ["InstructType"] = false,
        ["Prompt"] = true,
        ["Completion"] = true,
        ["Request"] = false,
        ["InputCacheRead"] = false,
        ["InputCacheWrite"] = false,
        ["Audio"] = false,
        ["Image"] = false,
        ["WebSearch"] = false,
        ["InternalReasoning"] = false,
        ["IsModerated"] = true,
        ["TopProviderContextLength"] = false,
        ["MaxCompletionTokens"] = false,
        ["PerRequestLimits"] = false,
        ["Created"] = true
    };

    private readonly List<string> priceRanges = new()
    {
        "Todos", "Grátis", "Até 0.0000001", "0.0000001 - 0.000001",
        "0.000001 - 0.00001", "0.00001 - 0.0001", "0.0001 - 0.001",
        "0.001 - 0.01", "0.01 - 0.1", "Acima de 0.1"
    };

    private readonly List<string> moderationOptions = new() { "Todos", "Moderado", "Não moderado" };
    private readonly List<string> contextRanges = new() { "Até 4096", "4096 - 8192", "8192 - 32768", "32768 - 100000", "Acima de 100000" };

    protected override void OnParametersSet()
    {
        _models = OpenRouterService.GetModels();

        if (_models?.Data != null && _models.Data.Any())
        {
            filteredModels = _models.Data.ToList();

            modalities = _models.Data
                .Select(m => m.Architecture?.Modality)
                .Where(m => !string.IsNullOrWhiteSpace(m))
                .Distinct()
                .OrderBy(m => m)
                .ToList()!;

            selectedColumns = visibleColumns.Where(kvp => kvp.Value).Select(kvp => kvp.Key).ToList();
        }

    }

    private void UpdateVisibleColumns()
    {
        foreach (var key in visibleColumns.Keys.ToList())
            visibleColumns[key] = selectedColumns.Contains(key);
    }

    private void ApplyFilter()
    {
        if (_models?.Data == null) return;

        filteredModels = _models.Data.Where(model =>
        {
            var preco = ParseDecimalSafe(model.Pricing?.Request);
            var contexto = model.ContextLength ?? 0;

            bool matchesText = string.IsNullOrWhiteSpace(filterName) ||
                ColumnMeta
                    .Where(kvp => visibleColumns[kvp.Key]) // só nas colunas visíveis
                    .Select(kvp => kvp.Value.ValueSelector(model))
                    .Any(value => value.Contains(filterName, StringComparison.OrdinalIgnoreCase));

            return
                matchesText &&
                (string.IsNullOrEmpty(selectedModality) || model.Architecture?.Modality == selectedModality) &&
                MatchPrice(preco) &&
                MatchModeration(model.TopProvider?.IsModerated) &&
                MatchContext(contexto);
        }).ToList();
    }

    private bool MatchPrice(decimal preco) => selectedPriceRange switch
    {
        "Grátis" => preco == 0,
        "Até 0.0000001" => preco <= 0.0000001m,
        "0.0000001 - 0.000001" => preco > 0.0000001m && preco <= 0.000001m,
        "0.000001 - 0.00001" => preco > 0.000001m && preco <= 0.00001m,
        "0.00001 - 0.0001" => preco > 0.00001m && preco <= 0.0001m,
        "0.0001 - 0.001" => preco > 0.0001m && preco <= 0.001m,
        "0.001 - 0.01" => preco > 0.001m && preco <= 0.01m,
        "0.01 - 0.1" => preco > 0.01m && preco <= 0.1m,
        "Acima de 0.1" => preco > 0.1m,
        _ => true
    };

    private bool MatchModeration(bool? isModerated) => selectedModeration switch
    {
        "Moderado" => isModerated == true,
        "Não moderado" => isModerated == false,
        _ => true
    };

    private bool MatchContext(int contexto) => selectedContextRange switch
    {
        "Até 4096" => contexto <= 4096,
        "4096 - 8192" => contexto > 4096 && contexto <= 8192,
        "8192 - 32768" => contexto > 8192 && contexto <= 32768,
        "32768 - 100000" => contexto > 32768 && contexto <= 100000,
        "Acima de 100000" => contexto > 100000,
        _ => true
    };

    private static decimal ParseDecimalSafe(string? value) =>
        decimal.TryParse(value, NumberStyles.Any, CultureInfo.InvariantCulture, out var result) ? result : 0;

    private static string FormatPrice(string? value, bool isPerToken = true)
    {
        if (string.IsNullOrWhiteSpace(value)) return "—";
        if (!decimal.TryParse(value, NumberStyles.Any, CultureInfo.InvariantCulture, out var d)) return value;

        if (d == 0) return "0";
        var price = isPerToken ? d * 1_000_000 : d;
        return isPerToken ? $"${price:0.######}/M tokens" : $"${price:0.######}/K tokens";
    }
}
